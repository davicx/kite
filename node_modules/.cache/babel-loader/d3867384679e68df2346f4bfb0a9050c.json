{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _generated = require(\"../validators/generated\");\nvar _default = toExpression;\nexports.default = _default;\nfunction toExpression(node) {\n  if ((0, _generated.isExpressionStatement)(node)) {\n    node = node.expression;\n  }\n  if ((0, _generated.isExpression)(node)) {\n    return node;\n  }\n  if ((0, _generated.isClass)(node)) {\n    node.type = \"ClassExpression\";\n  } else if ((0, _generated.isFunction)(node)) {\n    node.type = \"FunctionExpression\";\n  }\n  if (!(0, _generated.isExpression)(node)) {\n    throw new Error(`cannot turn ${node.type} to an expression`);\n  }\n  return node;\n}","map":{"version":3,"sources":["../../src/converters/toExpression.ts"],"names":["toExpression","node","expression","type","Error"],"mappings":";;;;;;AAAA,IAAA,UAAA,GAAA,OAAA,CAAA,yBAAA,CAAA;AAKiC,IAAA,QAAA,GAGlBA,YAAY;AAAA,OAAA,CAAA,OAAA,GAAA,QAAA;AAQ3B,SAASA,YAAY,CACnBC,IAAiE,EACnD;EACd,IAAI,CAAA,CAAA,EAAA,UAAA,CAAA,qBAAqB,EAACA,IAAI,CAAC,EAAE;IAC/BA,IAAI,GAAGA,IAAI,CAACC,UAAU;EACxB;EAQA,IAAI,CAAA,CAAA,EAAA,UAAA,CAAA,YAAY,EAACD,IAAI,CAAC,EAAE;IACtB,OAAOA,IAAI;EACb;EAKA,IAAI,CAAA,CAAA,EAAA,UAAA,CAAA,OAAO,EAACA,IAAI,CAAC,EAAE;IAEjBA,IAAI,CAACE,IAAI,GAAG,iBAAiB;EAC/B,CAAC,MAAM,IAAI,CAAA,CAAA,EAAA,UAAA,CAAA,UAAU,EAACF,IAAI,CAAC,EAAE;IAE3BA,IAAI,CAACE,IAAI,GAAG,oBAAoB;EAClC;EAGA,IAAI,CAAC,CAAA,CAAA,EAAA,UAAA,CAAA,YAAY,EAACF,IAAI,CAAC,EAAE;IACvB,MAAM,IAAIG,KAAK,CAAE,eAAcH,IAAI,CAACE,IAAK,mBAAkB,CAAC;EAC9D;EAEA,OAAOF,IAAI;AACb","sourcesContent":["import {\n  isExpression,\n  isFunction,\n  isClass,\n  isExpressionStatement,\n} from \"../validators/generated\";\nimport type * as t from \"..\";\n\nexport default toExpression as {\n  (node: t.Function): t.FunctionExpression;\n  (node: t.Class): t.ClassExpression;\n  (\n    node: t.ExpressionStatement | t.Expression | t.Class | t.Function,\n  ): t.Expression;\n};\n\nfunction toExpression(\n  node: t.ExpressionStatement | t.Expression | t.Class | t.Function,\n): t.Expression {\n  if (isExpressionStatement(node)) {\n    node = node.expression;\n  }\n\n  // return unmodified node\n  // important for things like ArrowFunctions where\n  // type change from ArrowFunction to FunctionExpression\n  // produces bugs like -> `()=>a` to `function () a`\n  // without generating a BlockStatement for it\n  // ref: https://github.com/babel/babili/issues/130\n  if (isExpression(node)) {\n    return node;\n  }\n\n  // convert all classes and functions\n  // ClassDeclaration -> ClassExpression\n  // FunctionDeclaration, ObjectMethod, ClassMethod -> FunctionExpression\n  if (isClass(node)) {\n    // @ts-expect-error todo(flow->ts): avoid type unsafe mutations\n    node.type = \"ClassExpression\";\n  } else if (isFunction(node)) {\n    // @ts-expect-error todo(flow->ts): avoid type unsafe mutations\n    node.type = \"FunctionExpression\";\n  }\n\n  // if it's still not an expression\n  if (!isExpression(node)) {\n    throw new Error(`cannot turn ${node.type} to an expression`);\n  }\n\n  return node;\n}\n"]},"metadata":{},"sourceType":"script"}